#!/usr/bin/perl 
#
BEGIN {
  my ($wd) = $0 =~ m-(.*)/- ;
  $wd ||= '.';
  unshift @INC,  "$wd/build";
  unshift @INC,  "$wd";
  unshift @INC,  "$ENV{'VIRTUAL_ENV'}/usr/lib/build"
}

use strict;
use YAML qw(LoadFile);
use warnings;
use threads;
use threads::shared;
use File::Find ();
use Term::ANSIColor qw(:constants);
use File::Path;
use File::Basename;
use URI;

# Global vars


# Flag to inform all threads that application is terminating
my $TERM:shared=0;

# Prevents double detach attempts
my $DETACHING:shared;

# Signal handling
$SIG{'INT'} = $SIG{'TERM'} = sub {
        print("^C captured\n");
        $TERM=1;
};

# Set the variable $File::Find::dont_use_nlink if you're using AFS,
# since AFS cheats.

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

my ($zname, $zpass, $zuid, $zgid, $zquota, $zcomment, $zgcos, $zdir, $zshell, $zexpire) = getpwnam(getlogin());

sub wanted;


use Cwd;
use Getopt::Long;
use Pod::Usage;
use File::Temp qw(tempfile);
use Build;
use Build::Rpm;
use Data::Dumper;
use File::Basename;

my @threads;
my @exclude = ();
my $arch = "i586";
my $path = "";
my $style = "git";
my $clean = 0;
my $binarylist = "";
my $buildall = 0;
my $dist = "tizen";
my $dryrun = 0;
my $help = 0;
my $keepgoing = 0;

my $virtualenv = "$ENV{'VIRTUAL_ENV'}";
my $build_root = $ENV{TIZEN_BUILD_ROOT};
my $localrepo = "$build_root/local/repos";
my $order_dir = "$build_root/local/order";


my $cache_dir = "$build_root/local/cache";
my $groupfile="$build_root/meta/group.xml";
my $build_dir = "$virtualenv/usr/lib/build";
my $config_filename = "$build_root/meta/local.yaml";
my $dist_configs = "$build_root/meta/dist";
my $exclude_from_file = "$build_root/meta/exclude";
my $cleanonce = 0;
my $debug = 0;
my $incremental = 0;
my $run_configure = 0;
my $overwrite = 0;
my $MAX_THREADS = 1;
my $suffix = "";

my @tobuild = ();
my @tofind = ();
my @final = ();
my %to_build = ();
my @done = ();
my @skipped = ();
my @original_specs = ();

my @cleaned : shared = ();
my @errors :shared;
my $packages_built :shared  = 0;
my %workers = ();

GetOptions (
    "arch=s" => \$arch,
    "clean" => \$clean,
    "clean-once" => \$cleanonce,
    "exclude=s" => \@exclude,
    "exclude-from-file=s" => \$exclude_from_file,
    "build-all" => \$buildall,
    "dist=s" => \$dist,
    "binary=s" => \$binarylist,
    "style=s" => \$style,
    "path=s" => \$path,
    "dryrun" => \$dryrun,
    "help|?" => \$help,
    "keepgoing" => \$keepgoing,
    "localrepo=s" => \$localrepo,
    "overwrite" => \$overwrite,
    "suffix=s" => \$suffix,
    "debug" => \$debug,
    "incremental" => \$incremental,
    "no-configure" => \$run_configure,
    "threads=s" => \$MAX_THREADS,
    );

my $Config = LoadFile($config_filename);
my @package_repos = ();
foreach my $r (@{$Config->{Repositories}}) {
    my $uri = URI->new($r->{Url});
    if ( $r->{Password} && $r->{Username} ) {
        $uri->userinfo($r->{Username} . ":" . $r->{Password});
    }
    if ($uri->scheme ne "file") {
        push(@package_repos, $uri);
    }
}

my $pkg_path = "$build_root/local/sources/$dist";
my $cache_path = "$build_root/local/sources/$dist/cache";
my $scratch_dir = "$build_root/local/scratch.$arch";


sub mkdir_p($) {
    my $path = shift;
    my $err_msg;
    # attempt a 'mkdir -p' on the provided path and catch any errors returned
    my $mkdir_out = File::Path::make_path( $path, { error => \my $err } );
    # catch and return the error if there was one
    if (@$err) {
        for my $diag (@$err) {
            my ( $file, $message ) = %$diag;
            $err_msg .= $message;
        }
        print STDERR "$err_msg";
    }
} 

sub debug {
    my $msg = shift;
    $msg =~ s#://[^@]*@#://#g;
    print YELLOW, "DEBUG: $msg\n", RESET if $debug == 1;
}

sub info {
    my $msg = shift;
    print GREEN, "$msg\n", RESET;
}

my $config = Build::read_config_dist($dist, $arch, $dist_configs);

if ( $exclude_from_file ne "" && -e $exclude_from_file ) {
    debug("using $exclude_from_file for package exclusion");
    open FILE, "<", $exclude_from_file  or die $!;
    @exclude = <FILE>;
    chomp(@exclude);
    close(FILE);
}


mkdir_p($order_dir);
mkdir_p "$localrepo/$dist/$arch/logs/success";
mkdir_p "$localrepo/$dist/$arch/logs/fail";
mkdir_p($cache_path);

my @packs = @ARGV;
my $package_path = "";
# FIXME

my @arm_archs = ("armv7l", "noarch");
my @ix86_archs = ("i586", "i686", "noarch");
my @archs = ();
if ( $arch eq "i586" ) {
    @archs = @ix86_archs;
} else {
    @archs = @arm_archs;
}
my $archpath;
foreach my $ap (@archs) {
    $archpath .= $ap.":"; 
}

if ( -d "packaging" && -d ".git" ) {
    $package_path = cwd();
} else {
    if ( $path eq "" ) {
        $package_path = "$build_root/packages";
    } else {
        $package_path = $path;
    }
}
if ($binarylist ne "") {
    $buildall = 1;
}

sub git_wanted {
    my ($dev,$ino,$mode,$nlink,$uid,$gid);
    /^packaging\z/s &&
    (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &&
    -d _
    && fill_packs_from_git($name, $config);
}


sub obs_wanted {
    /^.*\.spec\z/s && fill_packs_from_obs($name);
}

sub fill_packs_from_obs() {
    my $name = shift;
    $name =~ m/\.osc/ || push(@packs, $name);
}


sub fill_packs_from_git {
    my $name = shift;
    my $base = dirname($name);
    my $prj = basename($base);
    if ( ! -e "$base/.git" ) {
        debug("$base is not a git checkout");
        return;
    }
    if ( (grep $_ eq $prj, @exclude) ) {
        return;
    }
    debug("working on $base");
    my $pattern = "$name/*.spec";
    my @specs = glob $pattern;
    my $spec = "";
    if (@specs > 1 ) {
        if ( -e "$name/$prj.spec" ) {
            $spec = "$name/$prj.spec";
        } else {
            return;
        }
    } elsif (@specs) {
        $spec = $specs[0];
    } else {
        return;
    }
    push (@original_specs, $spec);
}


sub prepare_git {
    my $config = shift;
    my $spec = shift;

    my $packaging = dirname($spec);
    my $base = dirname($packaging);
    my $prj = basename($base);

    my $pack = Build::Rpm::parse($config, $spec);
    my $pkg_name = $pack->{name};
    my $pkg_version = $pack->{version};
    my $pkg_release = $pack->{release};
    my $spec_file = basename($spec);
    my $skip = 0;
    my $old_base = "";
    if ( -e "$base/.git" ) {
        open(GIT,"git --git-dir $base/.git rev-parse  HEAD |") || die "Failed: $!\n";
        while (my $current_rev = <GIT>) {
            chomp($current_rev);
            if ( system("grep -rq $current_rev $cache_path") == 0 ) {
               open(GREP,"grep -rl $current_rev $cache_path |") || die "Failed: $!\n";
               while ( <GREP> ) {
                    chomp;
                   $old_base = $_;
               }
               close(GREP);
               $skip = 1;
            }
            my @lines = ();
            if ( -e "$cache_path/$pkg_name-$pkg_version-$pkg_release" ) {
                open (REV, "< $cache_path/$pkg_name-$pkg_version-$pkg_release");
                @lines = <REV>;
            } else {
                open (REV, "> $cache_path/$pkg_name-$pkg_version-$pkg_release");
            }
            foreach my $old_rev(@lines) {
                if ( $current_rev eq $old_rev ) {
                    $skip = 1;
                }
            }
            close (REV); 
            open (REV1, "+> $cache_path/$pkg_name-$pkg_version-$pkg_release");
            print REV1 $current_rev . "\n";
            close (REV1); 
        }
        close(GIT);
    } else {
        debug("not a git repo: $base/.git!!");
    }
    if ($skip == 1) {
        if ( $old_base ne "" ) {
            $old_base = basename($old_base);
            push(@packs, "$pkg_path/$old_base/$spec_file");
        } else {
            push(@packs, "$pkg_path/$pkg_name-$pkg_version-$pkg_release/$spec_file");
        }
    } else {
        if ( system("gbs export  $base -o $pkg_path") == 0 ) {
            push(@packs, "$pkg_path/$pkg_name-$pkg_version-$pkg_release/$spec_file");
        } else {
            debug("$name was not exported correctly");
        }
    }
}


sub parse_packs {
    my ($config, @packs) = @_;
    my %packs = ();
    foreach my $spec (@packs) {
        my $pack = Build::Rpm::parse($config, $spec);
        if ( ( $pack->{'exclarch'} ) && ( ! grep $_ eq $arch, $pack->{'exclarch'} ) ) {
            next;
        }
        my $name = $pack->{name};
        my $version = $pack->{version};
        my $release = $pack->{release};
        my @buildrequires = $pack->{deps};
        my @subpacks = $pack->{subpacks};
        $packs{$name} = {
            name => $name,
            version => $version,
            release => $release,
            deps => @buildrequires,
            subpacks => @subpacks,
            filename => $spec
        }
    }
    return %packs;
}

sub expand_deps {
    my $spec = shift;
    my $rpmdeps = "$order_dir/.repo.cache";
    my (%fn, %prov, %req);

    my %packs;
    my %repo;
    my %ids;

    my %packs_arch;
    my %packs_done;
    open(F, '<', $rpmdeps) || die("$rpmdeps: $!\n");
    # WARNING: the following code assumes that the 'I' tag comes last
    my ($pkgF, $pkgP, $pkgR);
    while(<F>) {
      chomp;
      if (/^F:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgF = $2;
        next if $fn{$1};
        $fn{$1} = $2;
        my $pack = $1;
        $pack =~ /^(.*)\.([^\.]+)$/ or die;
        push @{$packs_arch{$2}}, $1;
      } elsif (/^P:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgP = $2;
        next if $prov{$1};
        $prov{$1} = $2;
      } elsif (/^R:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgR = $2;
        next if $req{$1};
        $req{$1} = $2;
      } elsif (/^I:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        if ($ids{$1} && $packs_done{$1} && defined($pkgF) && defined($pkgP) && defined($pkgR)) {
          my $i = $1;
          my $oldid = $ids{$1};
          my $newid = $2;
          if (Build::Rpm::verscmp($oldid, $newid) < 0) {
            $ids{$i}  = $newid;
            $fn{$i}   = $pkgF;
            $prov{$i} = $pkgP;
            $req{$i}  = $pkgR;
          }
        } else {
          next if $ids{$1};
          $ids{$1} = $2;
        }
        undef $pkgF;
        undef $pkgP;
        undef $pkgR;
      } elsif ($_ eq 'D:') {
        %packs_done = %ids;
      }
    }
    close F;

    for my $arch (@archs) {
      $packs{$_} ||= "$_.$arch" for @{$packs_arch{$arch} || []};
    }

    my $cf = Build::read_config_dist($dist, $archs[0], $dist_configs);
    $cf->{'warnings'} = 1;

    my $dofileprovides = %{$cf->{'fileprovides'}};

    for my $pack (keys %packs) {
      my $r = {};
      my (@s, $s, @pr, @re);
      @s = split(' ', $prov{$packs{$pack}} || '');
      while (@s) {
        $s = shift @s;
        next if !$dofileprovides && $s =~ /^\//;
        if ($s =~ /^rpmlib\(/) {
          splice(@s, 0, 2);
          next;
        }
        push @pr, $s;
        splice(@s, 0, 2) if @s && $s[0] =~ /^[<=>]/;
      }
      @s = split(' ', $req{$packs{$pack}} || '');
      while (@s) {
        $s = shift @s;
        next if !$dofileprovides && $s =~ /^\//;
        if ($s =~ /^rpmlib\(/) {
          splice(@s, 0, 2);
          next;
        }
        push @re, $s;
        splice(@s, 0, 2) if @s && $s[0] =~ /^[<=>]/;
      }
      $r->{'provides'} = \@pr;
      $r->{'requires'} = \@re;
      $repo{$pack} = $r;
    }
    my ($packname, $packvers, $subpacks, @packdeps);
    $subpacks = [];

    if ($spec) {
      my $d;
      if ($spec =~ /\.kiwi$/) {
        # just set up kiwi root for now
        $d = {
          'deps' => [ 'kiwi', 'zypper', 'createrepo', 'squashfs' ],
          'subpacks' => [],
        };
      } else {
        $d = Build::parse($cf, $spec);
      }
      $packname = $d->{'name'};
      $packvers = $d->{'version'};
      $subpacks = $d->{'subpacks'};
      @packdeps = @{$d->{'deps'} || []};
    }

    Build::readdeps($cf, undef, \%repo);

    #######################################################################
    my @extradeps = ();
    my @bdeps = Build::get_build($cf, $subpacks, @packdeps, @extradeps);

    return @bdeps;
}

sub createrepo
{
    my $arch = shift;
    my $dist = shift;

    mkdir_p "$localrepo/$dist/src/SRPMS";
    system ("cd $localrepo/$dist/src && rm -rf repodata && createrepo --changelog-limit=0 -q . > /dev/null 2>&1 ") == 0 or die "createrepo failed: $?\n";
    mkdir_p "$localrepo/$dist/$arch/RPMS";
    
    my $groups = "";
    if ( -e $groupfile ) {
        $groups = " --groupfile=$groupfile ";
    }

    system ("cd $localrepo/$dist/$arch && rm -rf repodata && createrepo $groups --changelog-limit=0 -q --exclude 'logs/*rpm' . > /dev/null 2>&1 ") == 0
        or die "createrepo failed: $?\n";
}

sub find_idle {
    my $idle = -1;
    foreach my $w (keys %workers) {
        my $tid = $workers{$w}->{tid};
        my $state = $workers{$w}->{state};
        if (! defined(threads->object($tid))) {
            set_idle($w);
            $idle = $w;
            last;
        }
    }
    foreach my $w (keys %workers) {
        if ( $workers{$w}->{state} eq 'idle' ) {
            $idle = $w;
            last;
        }
    }
    return $idle;
}

sub set_busy {
    my $worker = shift;
    my $thread = shift;
    $workers{$worker} = { 'state' => 'busy', 'tid' => $thread };
}

sub set_idle {
    my $worker = shift;
    $workers{$worker} = { 'state' => 'idle' , 'tid' => undef};
}

sub source_of {
    my ($sub, %packs) = @_;
    foreach my $x (keys %packs) {
        my @sp = @{$packs{$x}->{subpacks}};
        if (grep $_ eq $sub, @sp ) {
            return $x;
        }
    }
    return undef;
}

sub build_package {
    my ($name, $thread) = @_;
    use vars qw(@package_repos);

    my $version = $to_build{$name}->{version};
    my $release = $to_build{$name}->{release};
    my $spec_name = basename($to_build{$name}->{filename});
    my $pkg_path = "$build_root/local/sources/$dist/$name-$version-$release";
    my $srpm_filename = "";
    if ( $style eq "git" ) {
        $srpm_filename = "$pkg_path/$spec_name";
    } else {
        $srpm_filename = $to_build{$name}->{filename};
    }

    # Rebuild the package.
    info("*** building $name-$version-$release $arch $dist (worker: $thread) ***");

    $ENV{'BUILD_DIR'} = $build_dir;

    my $repos = "";
    if ( -d "$localrepo/$dist/$arch/RPMS" ) {
        $repos .= "--rpms $localrepo/$dist/$arch/RPMS ";
    }
    foreach my $r (@package_repos) {
        $repos .= "--repository $r ";
    }

    my $clean_option = "";
    if ( ($clean || $cleanonce ) && ( ! grep $_ == $thread, @cleaned) )  {
       $clean_option = " --clean "; 
       if ($cleanonce) {
            push(@cleaned, $thread);
       }
    }
    my $scratch = "$scratch_dir.$thread";

    my $redirect = "";
    if ($MAX_THREADS > 1 ) {
        $redirect = "> /dev/null 2>&1";
    }
    my $incremental_opt = "";
    if ($incremental == 1) {
        print "Doing incremental build\n";
        my $buildcmd = "";
        if ( ! -d "$scratch/home/abuild/rpmbuild/BUILD/$name-$version" ) {
            debug("Build directory exists");
            $incremental_opt = "--stage=\"-bp\"";
            $scratch = "$scratch_dir.incremental";
            $buildcmd = "sudo BUILD_ROOT=$scratch BUILD_DIR=\"$build_dir\" $virtualenv/usr/bin/build --arch $archpath --uid $zuid:$zgid --jobs 4 $clean_option $incremental_opt --cachedir $cache_dir --dist $dist --configdir $dist_configs $repos $srpm_filename $redirect  ";
            system ($buildcmd);
        } else {
            info("Build directory does not exist");
        }
        my $mount = "sudo mount -o bind $package_path $scratch/home/abuild/rpmbuild/BUILD/$name-$version";
        system($mount);
        $incremental_opt = "--short-circuit --stage=\"-bc\"";
        my $no_configure = "";
        if ($run_configure == 1 ) {
            $no_configure = "--define '%configure echo' --define '%autogen echo' --define '%reconfigure echo'";
        }
        $buildcmd = "sudo BUILD_ROOT=$scratch BUILD_DIR=\"$build_dir\" $virtualenv/usr/bin/build $no_configure --no-topdir-cleanup --no-init --arch $archpath --uid $zuid:$zgid --jobs 4 $clean_option $incremental_opt --cachedir $cache_dir --dist $dist --configdir $dist_configs $repos $srpm_filename $redirect  ";
        system ($buildcmd);
        $mount = "sudo umount $scratch/home/abuild/rpmbuild/BUILD/$name-$version";
        system($mount);
        # Detach and terminate
        {
            lock($DETACHING);
            threads->detach() if ! threads->is_detached();
        }
        print GREEN, "finished incremental building $name\n", RESET;
        exit(1);
    }

    my $buildcmd = "sudo BUILD_ROOT=$scratch BUILD_DIR=\"$build_dir\" $virtualenv/usr/bin/build --arch $archpath --uid $zuid:$zgid --jobs 4 $clean_option $incremental_opt --cachedir $cache_dir --dist $dist --configdir $dist_configs $repos $srpm_filename $redirect  ";
    debug("$buildcmd");
    if (system ($buildcmd) == 0 ) {
        system ("cp $scratch/home/abuild/rpmbuild/SRPMS/*.rpm $localrepo/$dist/src/SRPMS") == 0 or die "mv";
        system ("cp $scratch/home/abuild/rpmbuild/RPMS/*/*.rpm $localrepo/$dist/$arch/RPMS") == 0 or die "mv";
        mkdir_p "$localrepo/$dist/$arch/logs/success/$name-$version-$release";
        system ("cp $scratch/.build.log $localrepo/$dist/$arch/logs/success/$name-$version-$release/log") == 0 or die "mv";
        system ("cp $scratch/.srcfiles.cache $order_dir/.repo.cache") == 0 or die "mv";
        # Detach and terminate
        {
            lock($DETACHING);
            threads->detach() if ! threads->is_detached();
        }
        print GREEN, "finished building $name\n", RESET;
        $packages_built = 1;
        return(0);
    } else {
        mkdir_p "$localrepo/$dist/$arch/logs/fail/$name-$version-$release";
        if ( -f "$scratch/.build.log" ) {
            system ("cp $scratch/.build.log $localrepo/$dist/$arch/logs/fail/$name-$version-$release/log") == 0 or die "cp";
            print RED, "Build failed, Leaving the logs in $localrepo/$dist/$arch/logs/fail/$name-$version-$release/log\n", RESET;
        }
        push @errors, "$name-$dist-$arch$suffix";
        # Detach and terminate
        {
            lock($DETACHING);
            threads->detach() if ! threads->is_detached();
        }
        return 1;
    }

}



# MAIN
print "Start building packages from: " . $package_path . " ($style)\n";

if ($buildall || @packs == 0 ) {
    if ($style eq "git") {
        File::Find::find({wanted => \&git_wanted}, $package_path );
    } elsif ($style eq "obs") {
        File::Find::find({wanted => \&obs_wanted}, $package_path );
    }
} else {
    if (@packs == 0 && $path eq "") {
        print "Please provide a list of packages to build.";
        exit 1;
    }
}

print "Prepare sources...\n";
foreach my $sp (@original_specs) {
    prepare_git($config, $sp);
}

print "Parsing package data...\n";
my %packs = parse_packs($config, @packs);

if ($binarylist ne "" && -e $binarylist ) {
    open FILE, "<", $binarylist or die $!;
    my @bins = <FILE>;
    chomp(@bins);
    close(FILE);
    my @alldeps = ();
    foreach my $b (@bins) {
        next if $b eq "";
        my $found = 0;
        foreach my $name (keys %packs) {
            my @sp = @{$packs{$name}->{subpacks}};
            my $debuginfo = $b;
            $debuginfo =~ s/(.*)-debuginfo/$1/;
            $debuginfo =~ s/(.*)-debugsource/$1/;
            $debuginfo =~ s/(.*)-docs/$1/;
            my $nb;
            if ($b ne $debuginfo) { 
                $nb = $debuginfo;
            } else {
                $nb = $b;
            }
            if ( grep $_ eq $nb, @sp ) {
                push(@tobuild, $name);
                $found = 1 ;
                last;
            } 
        }
        if (!$found) {
            push(@tofind, $b);
        }
    }
    
    #print $_ . ", " foreach(sort @tobuild);
    #print "\n";
    #print $_ . ", " foreach(sort @tofind);
    #print "\n";
    foreach my $b (@tobuild) {
        my @bdeps = expand_deps($packs{$b}->{filename});
        if (!shift @bdeps ) {
            debug("expansion error");
            debug("  $_") for @bdeps;
        } else {
            #print $b . ": ";
            #print $_ . ", " foreach(sort @bdeps);
            #print "\n";
            @alldeps = (@bdeps, @alldeps);
        }
    }
    my %hash = map { $_, 1 } @alldeps;
    my @allbins = keys %hash;
    #print "Required dependencies: \n ";
    #print $_ . ", " foreach(sort @allbins);
    #print "\n";
    foreach (@allbins) {
        my $so = source_of($_, %packs);
        if ( defined($so)) {
            push(@tobuild, $so);
        }
    }

    %hash = map { $_, 1 } @tobuild;
    @tobuild = keys %hash;
    print "Initial set:\n";
    foreach my $p (@tobuild) {
        print " $p, ";
    }
    print "\n";
    foreach my $name (@tobuild) {
        my $fn = $packs{$name}->{filename};
        push(@final, $fn);
    }
    %to_build = parse_packs($config, @final);
} elsif ( $binarylist ne "") {
    print STDERR "Cant find binary list for image\n";
    exit 1;
} else {
    %to_build = %packs
}


# Prepare Workers
for(my $w = 0; $w < $MAX_THREADS; $w++) {
    $workers{$w} = { 'state' => 'idle' , 'tid' => undef };
}

if ( ! -e "$localrepo/$dist/$arch/RPMS" ) {
    print "Creating repo...";
    createrepo ($arch, $dist);
}

while (! $TERM) {
    my @order = ();
    my $repos_setup = 1;
    system("> $order_dir/.repo.cache");
    if ( system("$build_dir/createrpmdeps $localrepo/$dist/$arch/RPMS >> $order_dir/.repo.cache ") != 0 ) {
        $repos_setup = 0;
    }
    system("echo D: >> $order_dir/.repo.cache");
    foreach my $repo (@package_repos) {
        my $cmd = "$build_dir/createrepomddeps --cachedir=$order_dir $repo >> $order_dir/.repo.cache ";
        debug($cmd);
        if ( system($cmd) == 0 ) {
            system("echo D: >> $order_dir/.repo.cache");
        } else {
            $repos_setup = 0;
        }
    }
    if ($repos_setup == 0 ) {
        print "repo cache creation failed...\n";
        exit(1);
    }
    foreach my $name (keys %to_build) {
        if( ! (grep $_ eq $name, @done) && ! (grep $_ eq $name, @exclude)) {
            my $fn = $to_build{$name}->{filename};
            my $version = $to_build{$name}->{version};
            my $release = $to_build{$name}->{release};
            my $pattern = "$localrepo/$dist/src/SRPMS/$name-$version-$release.*.rpm";
            my @binaries = glob $pattern;
            if (@binaries != 0 && ! $overwrite) {
                info("skipping $name-$version-$release $arch $dist");
                push(@skipped, $name);
            } elsif (@binaries != 0 && $overwrite) {
                print "*** overwriting $name-$version-$release $arch $dist ***\n";
            }
        }
    }
    my @o = ();
    #foreach my $name (keys %to_build) {
    #    push(@o,$name);
    #}
    #print "Before order\n";
    #print " " . $_ . "\n" foreach (@o);
    #@o=Build::order($config, @o);
    #print "After order\n";
    #print " " . $_ . "\n" foreach (@o);
    foreach my $name (keys %to_build) {
        if( ! (grep $_ eq $name, @done) && 
            ! (grep $_ eq $name, @exclude) && 
            ! (grep $_ eq $name, @skipped)) 
        {
            my $fn = $to_build{$name}->{filename};
            my $version = $to_build{$name}->{version};
            my $release = $to_build{$name}->{release};
            my $pattern = "$localrepo/$dist/src/SRPMS/$name-$version-$release.*.rpm";
            my @binaries = glob $pattern;
            if (@binaries == 0 || $overwrite) {
                debug("Checking dependencies for $name");
                my $dd = "";
                if ( $debug ) {
                    $dd = "--debug";
                }
                my @bdeps = expand_deps($fn);
                if (!shift @bdeps ) {
                    debug("expansion error");
                    debug("  $_") for @bdeps;
                } else {
                    my $add = 1;
                    foreach my $depp (@bdeps) {
                        my $so = source_of($depp, %to_build);
                        if (defined($so) && $name ne $so
                            && (! grep($_ eq $so, @skipped)) && (! grep($_ eq $so, @done))) {
                            print "not adding $name, since it depends on $so\n";
                            $add = 0;
                            last;
                        }
                    }
                    if ($add == 1 ) {
                        push(@order, $name);
                    }
                }

            } 
        }
    }
    if (@order == 0) {
        last;
    } else {
        push(@done, @order);
        print "Next pass:\n";
        foreach my $o (@order) {
            print $o . "\n";
        }
    }
    if ($dryrun) {
        exit 1
    }

    while (@order && ! $TERM) {
        # Keep max threads running
        for (my $needed = $MAX_THREADS - threads->list(); 
            $needed && ! $TERM; $needed--) {

            my $job = shift(@order);
            last if (! $job);


            my $worker = find_idle();
            my $thr = threads->create('build_package',$job, $worker);
            my $tid = $thr->tid();
            set_busy($worker, $tid);
        }
    }

    while ((threads->list() > 0)) {
        # waiting for threads to finish
        sleep(1);
    }

}

if ($packages_built) {
    createrepo ($arch, $dist);
}

if (@errors) {
    print "\n\n\nBuild failed for the following packages:\n";
    print "  $_\n" foreach @errors;
    exit 1
}

exit 0
