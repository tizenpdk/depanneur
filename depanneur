#!/usr/bin/perl 
# 
# Copyright Intel Corp. 2012
# Author: Anas Nashif <anas.nashif@intel.com>
BEGIN {
  my ($wd) = $0 =~ m-(.*)/- ;
  $wd ||= '.';
  unshift @INC,  "$wd/build";
  unshift @INC,  "$wd";
  unshift @INC,  "$ENV{'VIRTUAL_ENV'}/usr/lib/build"
}

use strict;
use YAML qw(LoadFile);
use warnings;
use threads;
use threads::shared;
use File::Find ();
use Term::ANSIColor qw(:constants);
use File::Path;
use File::Basename;
use URI;

# Global vars


# Flag to inform all threads that application is terminating
my $TERM:shared=0;

# Prevents double detach attempts
my $DETACHING:shared;

# Signal handling
$SIG{'INT'} = $SIG{'TERM'} = sub {
        print("^C captured\n");
        $TERM=1;
};

# Set the variable $File::Find::dont_use_nlink if you're using AFS,
# since AFS cheats.

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

my ($zname, $zpass, $zuid, $zgid, $zquota, $zcomment, $zgcos, $zdir, $zshell, $zexpire) = getpwnam(getlogin());

sub wanted;


use Cwd;
use Getopt::Long;
use Pod::Usage;
use File::Temp qw(tempfile);
use Build;
use Build::Rpm;
use Data::Dumper;
use File::Basename;

my @threads;
my @exclude = ();
my $arch = "i586";
my $path = "";
my $style = "git";
my $clean = 0;
my $binarylist = "";
my $buildall = 0;
my $dist = "tizen";
my $dryrun = 0;
my $help = 0;
my $keepgoing = 0;

my $virtualenv = "$ENV{'VIRTUAL_ENV'}";
my $build_root = $ENV{TIZEN_BUILD_ROOT};
my $localrepo = "$build_root/local/repos";
my $order_dir = "$build_root/local/order";


my $cache_dir = "$build_root/local/cache";
my $groupfile="$build_root/meta/group.xml";
my $build_dir = "$virtualenv/usr/lib/build";
my $config_filename = "$build_root/meta/local.yaml";
my $dist_configs = "$build_root/meta/dist";
my $exclude_from_file = "$build_root/meta/exclude";
my $cleanonce = 0;
my $debug = 0;
my $incremental = 0;
my $turbu = 0;
my $run_configure = 0;
my $overwrite = 0;
my $MAX_THREADS = 1;

my @tobuild = ();
my @tofind = ();
my @final = ();
my %to_build = ();
my @done = ();
my @skipped = ();
my @original_specs = ();

my @cleaned : shared = ();
my @errors :shared;
my $packages_built :shared  = 0;
my %workers = ();


GetOptions (
    "arch=s" => \$arch,
    "dist=s" => \$dist,
    "clean" => \$clean,
    "clean-once" => \$cleanonce,
    "exclude=s" => \@exclude,
    "exclude-from-file=s" => \$exclude_from_file,
    "build-all" => \$buildall,
    "binary=s" => \$binarylist,
    "style=s" => \$style,
    "path=s" => \$path,
    "dryrun" => \$dryrun,
    "help|?" => \$help,
    "keepgoing" => \$keepgoing,
    "overwrite" => \$overwrite,
    "debug" => \$debug,
    "incremental" => \$incremental,
    "turbu" => \$turbu,
    "no-configure" => \$run_configure,
    "threads=s" => \$MAX_THREADS,
    );

if ( $help ) {
    print "
Depanneur is a package build tool based on the obs-build script.

Available options:

    --arch <Architecture>
      Build for the specificed architecture.

    --dist <Distribution>
      Build for the specificed distribution.

    --path <path to sources>
      Path to git repo tree, default is packages/ sub-directory
      in the developer environment.

    --clean 
      clean the build environment before building a package.

    --clean-once
      clean the build environment only once when you start 
      building multiple packages, after that use existing 
      environment for all packages.

    --threads  [number of threads]
      Build packages in parallel. This will start up to the 
      specificed number of build jobs when there are more 
      than 1 job in the queue.

    --overwrite
      Overwrite existing binaries.

    --keepgoing 
      If a package build fails, do not abort and continue
      building other packages in the queue.

    --incremental
      Build a package from the local git tree directly.
      This option does not produce packages now, it is very
      helpful when debugging build failures and helps with
      speeding up development.
      This option options mounts the local tree in the build
      environment and builds using sources in the git tree, 
      if the build fails, changes can be done directly to the
      source and build can continue from where it stopped.

    --no-configure
      This option disables running configure scripts and auto-
      generation of auto-tools to make incremental build possible
      It requires the configure scripts in the spec to be referreneced
      using the %configure, %reconfigre and %autogen macros.

    --debug
      Debug output.

";
    exit(0);
}


my $Config = LoadFile($config_filename);
if (!$Config) { 
    print "Error while parsing $config_filename";
    exit(1);
}
my @package_repos = ();
foreach my $r (@{$Config->{Repositories}}) {
    my $uri = URI->new($r->{Url});
    if ( $r->{Password} && $r->{Username} ) {
        $uri->userinfo($r->{Username} . ":" . $r->{Password});
    }
    if ($uri->scheme ne "file") {
        push(@package_repos, $uri);
    }
}

my $pkg_path = "$build_root/local/sources/$dist";
my $cache_path = "$build_root/local/sources/$dist/cache";
my $scratch_dir = "$build_root/local/scratch.$arch";


sub mkdir_p($) {
    my $path = shift;
    my $err_msg;
    # attempt a 'mkdir -p' on the provided path and catch any errors returned
    my $mkdir_out = File::Path::make_path( $path, { error => \my $err } );
    # catch and return the error if there was one
    if (@$err) {
        for my $diag (@$err) {
            my ( $file, $message ) = %$diag;
            $err_msg .= $message;
        }
        print STDERR "$err_msg";
    }
} 

sub debug {
    my $msg = shift;
    $msg =~ s#://[^@]*@#://#g;
    print YELLOW, "DEBUG: $msg\n", RESET if $debug == 1;
}

sub info {
    my $msg = shift;
    print GREEN, "$msg\n", RESET;
}


if ( $exclude_from_file ne "" && -e $exclude_from_file ) {
    debug("using $exclude_from_file for package exclusion");
    open FILE, "<", $exclude_from_file  or die $!;
    @exclude = <FILE>;
    chomp(@exclude);
    close(FILE);
}


mkdir_p($order_dir);
mkdir_p "$localrepo/$dist/$arch/logs/success";
mkdir_p "$localrepo/$dist/$arch/logs/fail";
mkdir_p($cache_path);

my @packs = @ARGV;
my $package_path = "";
# FIXME

my @arm_archs = ( "armv7el" , "armv7l", "noarch");
my @ix86_archs = ("i586", "i686", "noarch");
my @archs = ();
if ( $arch eq "i586" ) {
    @archs = @ix86_archs;
} else {
    @archs = @arm_archs;
}
my $archpath;
foreach my $ap (@archs) {
    $archpath .= $ap.":"; 
}
my $config = Build::read_config_dist($dist, $archpath, $dist_configs);

if ( -d "packaging" && -d ".git" ) {
    $package_path = cwd();
} else {
    if ( $path eq "" ) {
        $package_path = "$build_root/packages";
    } else {
        $package_path = $path;
    }
}
if ($binarylist ne "") {
    $buildall = 1;
}

sub git_wanted {
    my ($dev,$ino,$mode,$nlink,$uid,$gid);
    /^packaging\z/s &&
    (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &&
    -d _
    && fill_packs_from_git($name, $config);
}


sub obs_wanted {
    /^.*\.spec\z/s && fill_packs_from_obs($name);
}

sub fill_packs_from_obs() {
    my $name = shift;
    $name =~ m/\.osc/ || push(@packs, $name);
}


sub fill_packs_from_git {
    my $name = shift;
    my $base = dirname($name);
    my $prj = basename($base);
    if ( ! -e "$base/.git" ) {
        debug("$base is not a git checkout");
        return;
    }
    if ( (grep $_ eq $prj, @exclude) ) {
        return;
    }
    debug("working on $base");
    my $pattern = "$name/*.spec";
    my @specs = glob $pattern;
    my $spec = "";
    if (@specs > 1 ) {
        if ( -e "$name/$prj.spec" ) {
            $spec = "$name/$prj.spec";
        } else {
            return;
        }
    } elsif (@specs) {
        $spec = $specs[0];
    } else {
        return;
    }
    push (@original_specs, $spec);
}


sub prepare_git {
    my $config = shift;
    my $spec = shift;

    my $packaging = dirname($spec);
    my $base = dirname($packaging);
    my $prj = basename($base);

    my $pack = Build::Rpm::parse($config, $spec);
    my $pkg_name = $pack->{name};
    my $pkg_version = $pack->{version};
    my $pkg_release = $pack->{release};
    my $spec_file = basename($spec);
    my $skip = 0;
    my $old_base = "";
    if ( -e "$base/.git" ) {
        open(GIT,"git --git-dir $base/.git rev-parse  HEAD |") || die "Failed: $!\n";
        while (my $current_rev = <GIT>) {
            chomp($current_rev);
            if ( system("grep -rq $current_rev $cache_path") == 0 ) {
               open(GREP,"grep -rl $current_rev $cache_path |") || die "Failed: $!\n";
               while ( <GREP> ) {
                    chomp;
                   $old_base = $_;
               }
               close(GREP);
               $skip = 1;
            }
            my @lines = ();
            if ( -e "$cache_path/$pkg_name-$pkg_version-$pkg_release" ) {
                open (REV, "< $cache_path/$pkg_name-$pkg_version-$pkg_release");
                @lines = <REV>;
            } else {
                open (REV, "> $cache_path/$pkg_name-$pkg_version-$pkg_release");
            }
            foreach my $old_rev(@lines) {
                if ( $current_rev eq $old_rev ) {
                    $skip = 1;
                }
            }
            close (REV); 
            open (REV1, "+> $cache_path/$pkg_name-$pkg_version-$pkg_release");
            print REV1 $current_rev . "\n";
            close (REV1); 
        }
        close(GIT);
    } else {
        debug("not a git repo: $base/.git!!");
    }
    if ($skip == 1) {
        if ( $old_base ne "" ) {
            $old_base = basename($old_base);
            push(@packs, "$pkg_path/$old_base/$spec_file");
        } else {
            push(@packs, "$pkg_path/$pkg_name-$pkg_version-$pkg_release/$spec_file");
        }
    } else {
        if ( system("gbs export  $base -o $pkg_path") == 0 ) {
            push(@packs, "$pkg_path/$pkg_name-$pkg_version-$pkg_release/$spec_file");
        } else {
            debug("$name was not exported correctly");
        }
    }
}


sub parse_packs {
    my ($config, @packs) = @_;
    my %packs = ();
    foreach my $spec (@packs) {
        my $pack = Build::Rpm::parse($config, $spec);
        if ( ( $pack->{'exclarch'} ) &&  ( ! grep $_ eq $archs[0], @{$pack->{'exclarch'}} ) ) {
            debug("arch not compatible");
            next;
        }
        my $name = $pack->{name};
        my $version = $pack->{version};
        my $release = $pack->{release};
        my @buildrequires = $pack->{deps};
        my @subpacks = $pack->{subpacks};
        $packs{$name} = {
            name => $name,
            version => $version,
            release => $release,
            deps => @buildrequires,
            subpacks => @subpacks,
            filename => $spec
        }
    }
    return %packs;
}

sub expand_deps {
    my $spec = shift;
    my $rpmdeps = "$order_dir/.repo.cache";
    my (%fn, %prov, %req);

    my %packs;
    my %repo;
    my %ids;

    my %packs_arch;
    my %packs_done;
    open(F, '<', $rpmdeps) || die("$rpmdeps: $!\n");
    # WARNING: the following code assumes that the 'I' tag comes last
    my ($pkgF, $pkgP, $pkgR);
    while(<F>) {
      chomp;
      if (/^F:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgF = $2;
        next if $fn{$1};
        $fn{$1} = $2;
        my $pack = $1;
        $pack =~ /^(.*)\.([^\.]+)$/ or die;
        push @{$packs_arch{$2}}, $1;
      } elsif (/^P:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgP = $2;
        next if $prov{$1};
        $prov{$1} = $2;
      } elsif (/^R:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        $pkgR = $2;
        next if $req{$1};
        $req{$1} = $2;
      } elsif (/^I:(.*?)-\d+\/\d+\/\d+: (.*)$/) {
        if ($ids{$1} && $packs_done{$1} && defined($pkgF) && defined($pkgP) && defined($pkgR)) {
          my $i = $1;
          my $oldid = $ids{$1};
          my $newid = $2;
          if (Build::Rpm::verscmp($oldid, $newid) < 0) {
            $ids{$i}  = $newid;
            $fn{$i}   = $pkgF;
            $prov{$i} = $pkgP;
            $req{$i}  = $pkgR;
          }
        } else {
          next if $ids{$1};
          $ids{$1} = $2;
        }
        undef $pkgF;
        undef $pkgP;
        undef $pkgR;
      } elsif ($_ eq 'D:') {
        %packs_done = %ids;
      }
    }
    close F;

    for my $arch (@archs) {
      $packs{$_} ||= "$_.$arch" for @{$packs_arch{$arch} || []};
    }

    my $cf = Build::read_config_dist($dist, $archpath, $dist_configs);
    $cf->{'warnings'} = 1;

    my $dofileprovides = %{$cf->{'fileprovides'}};

    for my $pack (keys %packs) {
      my $r = {};
      my (@s, $s, @pr, @re);
      @s = split(' ', $prov{$packs{$pack}} || '');
      while (@s) {
        $s = shift @s;
        next if !$dofileprovides && $s =~ /^\//;
        if ($s =~ /^rpmlib\(/) {
          splice(@s, 0, 2);
          next;
        }
        push @pr, $s;
        splice(@s, 0, 2) if @s && $s[0] =~ /^[<=>]/;
      }
      @s = split(' ', $req{$packs{$pack}} || '');
      while (@s) {
        $s = shift @s;
        next if !$dofileprovides && $s =~ /^\//;
        if ($s =~ /^rpmlib\(/) {
          splice(@s, 0, 2);
          next;
        }
        push @re, $s;
        splice(@s, 0, 2) if @s && $s[0] =~ /^[<=>]/;
      }
      $r->{'provides'} = \@pr;
      $r->{'requires'} = \@re;
      $repo{$pack} = $r;
    }
    my ($packname, $packvers, $subpacks, @packdeps);
    $subpacks = [];

    if ($spec) {
      my $d;
      if ($spec =~ /\.kiwi$/) {
        # just set up kiwi root for now
        $d = {
          'deps' => [ 'kiwi', 'zypper', 'createrepo', 'squashfs' ],
          'subpacks' => [],
        };
      } else {
        $d = Build::parse($cf, $spec);
      }
      $packname = $d->{'name'};
      $packvers = $d->{'version'};
      $subpacks = $d->{'subpacks'};
      @packdeps = @{$d->{'deps'} || []};
    }

    Build::readdeps($cf, undef, \%repo);

    #######################################################################
    my @extradeps = ();
    my @bdeps = Build::get_build($cf, $subpacks, @packdeps, @extradeps);

    return @bdeps;
}

sub createrepo
{
    my $arch = shift;
    my $dist = shift;
    mkdir_p "$localrepo/$dist/src/SRPMS";
    system ("cd $localrepo/$dist/src && rm -rf repodata && createrepo --changelog-limit=0 -q . > /dev/null 2>&1 ") == 0 or die "createrepo failed: $?\n";
    mkdir_p "$localrepo/$dist/$arch/RPMS";
    system("touch $localrepo/$dist/$arch/RPMS");
    
    my $groups = "";
    if ( -e $groupfile ) {
        $groups = " --groupfile=$groupfile ";
    }

    system ("cd $localrepo/$dist/$arch && rm -rf repodata && createrepo $groups --changelog-limit=0 -q --exclude 'logs/*rpm' . > /dev/null 2>&1 ") == 0
        or die "createrepo failed: $?\n";
}

sub find_idle {
    my $idle = -1;
    foreach my $w (keys %workers) {
        my $tid = $workers{$w}->{tid};
        my $state = $workers{$w}->{state};
        if (! defined(threads->object($tid))) {
            set_idle($w);
            $idle = $w;
            last;
        }
    }
    foreach my $w (keys %workers) {
        if ( $workers{$w}->{state} eq 'idle' ) {
            $idle = $w;
            last;
        }
    }
    return $idle;
}

sub set_busy {
    my $worker = shift;
    my $thread = shift;
    $workers{$worker} = { 'state' => 'busy', 'tid' => $thread };
}

sub set_idle {
    my $worker = shift;
    $workers{$worker} = { 'state' => 'idle' , 'tid' => undef};
}

sub source_of {
    my ($sub, %packs) = @_;
    foreach my $x (keys %packs) {
        my @sp = @{$packs{$x}->{subpacks}};
        if (grep $_ eq $sub, @sp ) {
            return $x;
        }
    }
    return undef;
}

sub build_package {
    my ($name, $thread) = @_;
    use vars qw(@package_repos);

    my $version = $to_build{$name}->{version};
    my $release = $to_build{$name}->{release};
    my $spec_name = basename($to_build{$name}->{filename});
    my $pkg_path = "$build_root/local/sources/$dist/$name-$version-$release";
    my $srpm_filename = "";
    if ( $style eq "git" ) {
        $srpm_filename = "$pkg_path/$spec_name";
    } else {
        $srpm_filename = $to_build{$name}->{filename};
    }

    my @args = ();
    my @args_inc = ();
    push @args, "sudo -E $virtualenv/usr/bin/build";
    if ($arch ne "i586" ) {
        push @args, "--use-system-qemu";
    }
    push @args, "--uid $zuid:$zgid";
    push @args, "--jobs 4";
    push @args, "--cachedir $cache_dir";
    push @args, "--dist $dist";
    push @args, "--configdir $dist_configs";
    push @args, "--arch $archpath";
    push @args, "$srpm_filename";

    # Rebuild the package.
    info("*** building $name-$version-$release $arch $dist (worker: $thread) ***");

    $ENV{'BUILD_DIR'} = $build_dir;

    if ( -d "$localrepo/$dist/$arch/RPMS" ) {
        push @args, "--rpms $localrepo/$dist/$arch/RPMS";
    }
    foreach my $r (@package_repos) {
        push @args, "--repository $r";
    }

    if ( ($clean || $cleanonce ) && ( ! grep $_ == $thread, @cleaned) )  {
       push @args, "--clean";
       if ($cleanonce) {
            push(@cleaned, $thread);
       }
    }
    my $scratch = "$scratch_dir.$thread";

    my $redirect = "";
    if ($MAX_THREADS > 1 ) {
        $redirect = "> /dev/null 2>&1";
    }
    @args_inc = @args;
    my $cmd = "";
    if ($incremental == 1) {
        print "Doing incremental build\n";
        my $buildcmd = "";
        if ( ! -d "$scratch/home/abuild/rpmbuild/BUILD/$name-$version" ) {
            debug("Build directory exists");
            $scratch = "$scratch_dir.incremental";
            push @args, "--stage=\"-bp\"";
            push @args, "--root $scratch";
            push @args, "--clean";
            push @args, $redirect;
            $cmd = join(" ", @args);
            system ($cmd);
        } else {
            info("Build directory does not exist");
        }
        my $mount = "sudo mount -o bind $package_path $scratch/home/abuild/rpmbuild/BUILD/$name-$version";
        system($mount);
        if ($run_configure == 1 ) {
            push @args_inc, "--define '%configure echo'";
            push @args_inc, "--define '%reconfigure echo'";
            push @args_inc, "--define '%autogen echo'";
        }
        push @args_inc, "--stage=\"-bp\"";
        push @args_inc, "--root $scratch";
        push @args_inc, "--no-topdir-cleanup";
        push @args_inc, "--no-init";
        push @args_inc, "--short-circuit --stage=\"-bc\"";
        push @args_inc, $redirect;
        $cmd = join(" ", @args_inc);
        system ($cmd);

        $mount = "sudo umount $scratch/home/abuild/rpmbuild/BUILD/$name-$version";
        system($mount);
        # Detach and terminate
        {
            lock($DETACHING);
            threads->detach() if ! threads->is_detached();
        }
        print GREEN, "finished incremental building $name\n", RESET;
        exit(1);
    } else {
        push @args, "--root $scratch";
    }
    
    $cmd = join(" ", @args);
    debug($cmd);
    if (system ($cmd) == 0 ) {
        system ("cp $scratch/home/abuild/rpmbuild/SRPMS/*.rpm $localrepo/$dist/src/SRPMS") == 0 or die "mv";
        system ("cp $scratch/home/abuild/rpmbuild/RPMS/*/*.rpm $localrepo/$dist/$arch/RPMS") == 0 or die "mv";
        mkdir_p "$localrepo/$dist/$arch/logs/success/$name-$version-$release";
        system ("cp $scratch/.build.log $localrepo/$dist/$arch/logs/success/$name-$version-$release/log") == 0 or die "mv";
        system ("cp $scratch/.srcfiles.cache $order_dir/.repo.cache") == 0 or die "mv";
        # Detach and terminate
        {
            lock($DETACHING);
            threads->detach() if ! threads->is_detached();
        }
        print GREEN, "finished building $name\n", RESET;
        $packages_built = 1;
        return(0);
    } else {
        mkdir_p "$localrepo/$dist/$arch/logs/fail/$name-$version-$release";
        if ( -f "$scratch/.build.log" ) {
            system ("cp $scratch/.build.log $localrepo/$dist/$arch/logs/fail/$name-$version-$release/log") == 0 or die "cp";
            print RED, "Build failed, Leaving the logs in $localrepo/$dist/$arch/logs/fail/$name-$version-$release/log\n", RESET;
        }
        push @errors, "$name-$dist-$arch";
        # Detach and terminate
        {
            lock($DETACHING);
            threads->detach() if ! threads->is_detached();
        }
        return 1;
    }

}



# MAIN
print "Start building packages from: " . $package_path . " ($style)\n";

if ($buildall || @packs == 0 ) {
    if ($style eq "git") {
        File::Find::find({wanted => \&git_wanted}, $package_path );
    } elsif ($style eq "obs") {
        File::Find::find({wanted => \&obs_wanted}, $package_path );
    }
} else {
    if (@packs == 0 && $path eq "") {
        print "Please provide a list of packages to build.";
        exit 1;
    }
}

print "Prepare sources...\n";
foreach my $sp (@original_specs) {
    prepare_git($config, $sp);
}

print "Parsing package data...\n";
my %packs = parse_packs($config, @packs);

if ($binarylist ne "" && -e $binarylist ) {
    open FILE, "<", $binarylist or die $!;
    my @bins = <FILE>;
    chomp(@bins);
    close(FILE);
    my @alldeps = ();
    foreach my $b (@bins) {
        next if $b eq "";
        my $found = 0;
        foreach my $name (keys %packs) {
            my @sp = @{$packs{$name}->{subpacks}};
            my $debuginfo = $b;
            $debuginfo =~ s/(.*)-debuginfo/$1/;
            $debuginfo =~ s/(.*)-debugsource/$1/;
            $debuginfo =~ s/(.*)-docs/$1/;
            my $nb;
            if ($b ne $debuginfo) { 
                $nb = $debuginfo;
            } else {
                $nb = $b;
            }
            if ( grep $_ eq $nb, @sp ) {
                push(@tobuild, $name);
                $found = 1 ;
                last;
            } 
        }
        if (!$found) {
            push(@tofind, $b);
        }
    }
    
    #print $_ . ", " foreach(sort @tobuild);
    #print "\n";
    #print $_ . ", " foreach(sort @tofind);
    #print "\n";
    foreach my $b (@tobuild) {
        my @bdeps = expand_deps($packs{$b}->{filename});
        if (!shift @bdeps ) {
            debug("expansion error");
            debug("  $_") for @bdeps;
        } else {
            #print $b . ": ";
            #print $_ . ", " foreach(sort @bdeps);
            #print "\n";
            @alldeps = (@bdeps, @alldeps);
        }
    }
    my %hash = map { $_, 1 } @alldeps;
    my @allbins = keys %hash;
    #print "Required dependencies: \n ";
    #print $_ . ", " foreach(sort @allbins);
    #print "\n";
    foreach (@allbins) {
        my $so = source_of($_, %packs);
        if ( defined($so)) {
            push(@tobuild, $so);
        }
    }

    %hash = map { $_, 1 } @tobuild;
    @tobuild = keys %hash;
    print "Initial set:\n";
    foreach my $p (@tobuild) {
        print " $p, ";
    }
    print "\n";
    foreach my $name (@tobuild) {
        my $fn = $packs{$name}->{filename};
        push(@final, $fn);
    }
    %to_build = parse_packs($config, @final);
} elsif ( $binarylist ne "") {
    print STDERR "Cant find binary list for image\n";
    exit 1;
} else {
    %to_build = %packs
}


# Prepare Workers
for(my $w = 0; $w < $MAX_THREADS; $w++) {
    $workers{$w} = { 'state' => 'idle' , 'tid' => undef };
}

if ( ! -e "$localrepo/$dist/$arch/RPMS" ) {
    print "Creating repo...";
    createrepo ($arch, $dist);
}

while (! $TERM) {
    my @order = ();
    if (! $turbu) {
        my $repos_setup = 1;
        system("> $order_dir/.repo.cache");
        if ( system("$build_dir/createrpmdeps $localrepo/$dist/$arch/RPMS >> $order_dir/.repo.cache ") != 0 ) {
            $repos_setup = 0;
        }
        system("echo D: >> $order_dir/.repo.cache");
        foreach my $repo (@package_repos) {
            my $cmd = "$build_dir/createrepomddeps --cachedir=$order_dir $repo >> $order_dir/.repo.cache ";
            debug($cmd);
            if ( system($cmd) == 0 ) {
                system("echo D: >> $order_dir/.repo.cache");
            } else {
                $repos_setup = 0;
            }
        }
        if ($repos_setup == 0 ) {
            print "repo cache creation failed...\n";
            exit(1);
        }
    }
    foreach my $name (keys %to_build) {
        if( ! (grep $_ eq $name, @done) && ! (grep $_ eq $name, @exclude)) {
            my $fn = $to_build{$name}->{filename};
            my $version = $to_build{$name}->{version};
            my $release = $to_build{$name}->{release};
            my $pattern = "$localrepo/$dist/src/SRPMS/$name-$version-$release.*.rpm";
            my @binaries = glob $pattern;
            if (@binaries != 0 && ! $overwrite) {
                info("skipping $name-$version-$release $arch $dist");
                push(@skipped, $name);
            } elsif (@binaries != 0 && $overwrite) {
                print "*** overwriting $name-$version-$release $arch $dist ***\n";
            }
        }
    }
    my @o = ();
    #foreach my $name (keys %to_build) {
    #    push(@o,$name);
    #}
    #print "Before order\n";
    #print " " . $_ . "\n" foreach (@o);
    #@o=Build::order($config, @o);
    #print "After order\n";
    #print " " . $_ . "\n" foreach (@o);
    foreach my $name (keys %to_build) {
        if( ! (grep $_ eq $name, @done) && 
            ! (grep $_ eq $name, @exclude) && 
            ! (grep $_ eq $name, @skipped)) 
        {
            my $fn = $to_build{$name}->{filename};
            my $version = $to_build{$name}->{version};
            my $release = $to_build{$name}->{release};
            my $pattern = "$localrepo/$dist/src/SRPMS/$name-$version-$release.*.rpm";
            my @binaries = glob $pattern;
            if (@binaries == 0 || $overwrite) {
                debug("Checking dependencies for $name");
                my $dd = "";
                if ( $debug ) {
                    $dd = "--debug";
                }
                my @bdeps = expand_deps($fn);
                if (!shift @bdeps ) {
                    debug("expansion error");
                    debug("  $_") for @bdeps;
                } else {
                    my $add = 1;
                    foreach my $depp (@bdeps) {
                        my $so = source_of($depp, %to_build);
                        if (defined($so) && $name ne $so
                            && (! grep($_ eq $so, @skipped)) && (! grep($_ eq $so, @done))) {
                            print "Not adding $name, since it depends on $so (cycle?)\n";
                            $add = 0;
                            last;
                        }
                    }
                    if ($add == 1 ) {
                        push(@order, $name);
                    }
                }

            } 
        }
    }
    if (@order == 0) {
        last;
    } else {
        push(@done, @order);
        print "Next pass:\n";
        foreach my $o (@order) {
            print $o . "\n";
        }
    }
    if ($dryrun) {
        exit 1
    }

    while (@order && ! $TERM) {
        # Keep max threads running
        for (my $needed = $MAX_THREADS - threads->list(); 
            $needed && ! $TERM; $needed--) {

            my $job = shift(@order);
            last if (! $job);


            my $worker = find_idle();
            my $thr = threads->create('build_package',$job, $worker);
            my $tid = $thr->tid();
            set_busy($worker, $tid);
        }
    }

    while ((threads->list() > 0)) {
        # waiting for threads to finish
        sleep(1);
    }

}

if ($packages_built) {
    info("Updating local repo");
    createrepo ($arch, $dist);
}

if (@errors) {
    print "\n\n\nBuild failed for the following packages:\n";
    print "  $_\n" foreach @errors;
    exit 1
}

exit 0
